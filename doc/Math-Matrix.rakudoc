=begin pod

=head1 NAME

Math::Matrix - create, compare, compute and measure 2D matrices

=head1 SYNOPSIS

Matrices are tables with rows and columns (index counting from 0)
of numbers (Numeric type - Bool or Int or Num or Rat or FatRat or Complex):

 transpose, invert, negate, add, multiply, dot product, tensor product, 22 ops, determinant, rank, norm
 14 numerical properties, 26 boolean properties, 3 decompositions, submatrix, splice, map, reduce and more

Table of Content:

=item L<Methods|#methods>
=item L<Operators|#operators>
=item L<Export Tags|#export-tags>
=item L<Authors|#authors>
=item L<License|#license>

=head1 DESCRIPTION

Because the list based, functional toolbox of Raku is not enough to calculate matrices comfortably,
there is a need for a dedicated data type. The aim is to provide a full featured set of structural and
mathematical operations that integrate fully with the Raku conventions.
This module is pure Raku and we plan to use native shaped arrays one day.

Matrices are readonly - methods and operators do create new matrix objects.
All methods return readonly data or deep clones - also the constructor does a deep clone of provided data.
In that sense the library is thread safe.

All computation heavy properties will be calculated lazily and cached.
Mathematically or otherwise undefined operations will cause an exception.

=head1 L<METHODS|#synopsis>
=item B<L<constructors|#constructors>>: L<new []|#new-->, L<new ()|#new---1>, L<new ""|#new---2>,
        L<new-zero|#new-zero>, L<new-identity|#new-identity>, L<new-diagonal|#new-diagonal>, L<new-vector-product|#new-vector-product>
=item B<L<accessors|#accessors>>: L<element|#element>, L<AT-POS|#at-pos>, L<row|#row>, L<column|#column>,
        L<diagonal|#diagonal>, L<skew-diagonal|#skew-diagonal>, L<submatrix|#submatrix>
=item B<L<converter|#converter>>: L<Bool|#bool>, L<Str|#str>, L<Numeric|#numeric>, L<Range|#range>,
        L<Array|#array>, L<list|#list>, L<list-rows|#list-rows>, L<list-columns|#list-columns>, L<Hash|#hash>, L<gist|#gist>, L<raku|#raku>
=item B<L<boolean properties|#boolean-properties>>: L<zero|#is-zero>, L<identity|#is-identity>,
        L<square|#is-square>, L<triangular|#is-triangular>, L<tri-|#is-tridiagonal>, L<anti-|#is-anti-diagonal>, L<diagonal|#is-diagonal>,
        L<-dominant|#is-diagonally-dominant>, L<-constant|#is-diagonal-constant>, L<catalecticant|#is-catalecticant>,
        L<anti-|#is-antisymmetric>, L<symmetric|#is-symmetric>, L<unitary|#is-unitary>, L<self-adjoint|#is-self-adjoint>, L<invertible|#is-invertible>, L<orthogonal|#is-orthogonal>,
        L<positive-definite|#is-positive-definite>, L<positive-semidefinite|#is-positive-semidefinite>
=item B<L<numeric properties|#numeric-properties>>: L<size|#size>, L<density|#density>, L<bandwith|#bandwith>,
        L<trace|#trace>, L<rank|#rank>, L<nullity|#nullity>, L<determinant|#determinant>,
        L<minor|#minor>, L<norm|#norm>, L<condition|#condition>, L<element-type|#element-type>
=item B<L<derived matrices|#drived-matrices>>: L<transposed|#transposed>, L<negated|#negated>,
        L<conjugated|#conjugated>, L<adjugated|#adjugated>, L<inverted|#inverted>, L<reduced-row-echelon-form>
=item B<L<decompositions|#decompositions>>: L<LU|#LU-decomposition>, L<LDU|#LU-decomposition>, L<Cholesky|#Cholesky-decomposition>, L<LDL|#Cholesky-decomposition>
=item B<L<math ops|#mathematical-operations>>: L<equal|#equal>, L<add|#add>, L<multiply|#multiply>, L<dot-product|#dot-product>, L<tensor-product|#tensor-product>
=item B<L<list like ops|#list-like-operations>>: L<elems|#elems>, L<elem|#elem>, L<cont|#cont>,
        L<map|#map>, L<map-with-index|#map-with-index>, L<reduce|#reduce>, L<reduce-rows|#reduce-rows>, L<reduce-columns|#reduce-columns>
=item B<L<structural ops|#structural-operations>>: L<move-row|#move-row>, L<move-column|#move-column>,
        L<swap-rows|#swap-rows>, L<swap-columns|#swap-columns>, L<splice-rows|#splice-rows>, L<splice-columns|#splice-columns>
=item B<L<shortcuts|#shortcuts>>:   L<T|#transposed>,   L<conj|#conjugated>,   L<det|#determinant>,   L<rref|#reduced-row-echelon-form>
=item B<L<operators|#operator-methods>>:   MM,  ?,  ~,  |,  @,  %,  +,  -,  *,  **,  dot,  ⋅,  ÷,  X*,  ⊗,  ==,  ~~,  ❘ ❘,  ‖ ‖,  [ ]

=head2 L<Constructors|#methods>

Methods that create a new Math::Matrix object. The default is of course .new, which can take array of array of values (fastest) or one string.
Additional constructers: L<new-zero|#new-zero>, L<new-identity|#new-identity>, L<new-diagonal|#new-diagonal> and L<new-vector-product|#new-vector-product>
are there for convenience and to optimize property calculation.

=head3 L<new( [[...],...,[...]] )|#constructors>

The default constructor, takes arrays of arrays of numbers as the only required parameter.
Each second level array represents a row in the matrix.
That is why their length has to be the same.
Empty rows or columns we not be accepted.

=begin code :lang<raku>

say Math::Matrix.new( [[1,2],[3,4]] ) :
1 2
3 4

Math::Matrix.new([<1 2>,<3 4>]); # does the same, WARNING: doesn't work with complex numbers
Math::Matrix.new( [[1]] );       # one element 1*1 matrix (exception where you don't have to mind comma)
Math::Matrix.new( [[1,2,3],] );  # one row 1*3 matrix, mind the trailing comma
Math::Matrix.new( [$[1,2,3]] );  # does the same, if you don't like trailing comma
Math::Matrix.new( [[1],[2]] );   # one column 2*1 matrix

use Math::Matrix :MM;            # tag :ALL works too
MM [[1,2],[3,4]];                # shortcut

=end code

=head3 L<new( ((...),...,(...)) )|#constructors>

Instead of square brackets you can use round ones too and use a list of lists as argument too.

=begin code :lang<raku>

say Math::Matrix.new( ((1,2),(3,4)) );
say MM ((1,2),(3,4)) :
1 2
3 4

=end code

=head3 L<new( "..." )|#constructors>

Alternatively you can define the matrix from a string, which makes most sense while using heredocs.

=begin code :lang<raku>

Math::Matrix.new("1 2 \n 3 4"); # our demo matrix as string
Math::Matrix.new: q:to/END/;    # indent as you wish
   1 2
   3 4
 END

use Math::Matrix :ALL;          #
MM '1';                         # 1 * 1 matrix, this case begs for a shortcut

=end codd

=head3 L<new-zero|#constructors>

This method is a constructor, that returns a I<zero> matrix, which is sometimes called empty.
That is a matrix, which holds zeros in all its L<element|#element>s (as checked by L<is-zero|#is-zero>).

I<new-zero> needs one ore two integer arguments. These are the numbers of rows and columns -
the size L<size|#size> of the new matrix. If both numbers are the same, you can omit the ladder
and get a L<quadratic|#is-square> matrix filld with zeros.

=begin code :lang<raku>

say Math::Matrix.new-zero( 3, 4 ) :

0 0 0 0
0 0 0 0
0 0 0 0

say Math::Matrix.new-zero( 2 ) :

0 0
0 0

=end code

=head3 L<new-identity|#constructors>

This method creates a new I<identity matrix> (as checked by L<is-identity|#is-identity>).
It contains only zeros, except in the main L<diagonal|#diagonal>, which consist of ones.
Since identity matrices have to be L<quadratic|#is-square>, I<new-identity>
requires only one integer arguments, which sets the number of rows and columns of the
new matrix.

=begin code :lang<raku>

say Math::Matrix.new-identity( 3 ) :

1 0 0
0 1 0
0 0 1

=end code

=head3 L<new-diagonal|#constructors>

creates a I<diagonal> matrix (as checked by L<is-diagonal|#is-diagonal>),
which contains zeros, except in the main L<diagonal|#diagonal>, that can hold arbitrary values.
The only required argument is a list these arbitrary numbers,
which will become the content of the main diagonal.

=begin code :lang<raku>

say Math::Matrix.new-diagonal( 2, 4, 5 ) :

2 0 0
0 4 0
0 0 5

=end code

=head3 L<new-vector-product|#constructors>

creates a matrix by calculating the L<tensor-product|#tensor-product> of two vectors,
which are in a list or Array form the two required arguments of the method.
Both lists don't have to be of the same size. The length of the first list will
determine the amount of rows and the length of the second the amount of columns.

=begin code :lang<raku>

say Math::Matrix.new-vector-product([1,2,3],[2,3,4]) :

*    2    3    4
1  1*2  1*3  1*4     2  3  4
2  2*2  2*3  2*4  =  4  6  8
3  3*2  3*3  3*4     6  9 12

=end code

=head2 L<Accessors|#methods>

Methods that return the content of selected elements.

L<element|#element>, L<AT-POS|#at-pos>, L<row|#row>, L<column|#column>, L<diagonal|#diagonal>, L<skew-diagonal>,
B<L<submatrix>>: (L<leaving out one|#leaving-out-one>, L<leaving out more|#leaving-out-more>, L<reordering|#reordering>)

=head3 L<element|#accessors>

Gets value of one element in L<row|#row> (first parameter) and L<column|#column> (second parameter - counting always from 0).
Sometimes its called matrix cell, to distinct from other type of elements.
See: L<elems|elems>, L<elem|elem>, L<element-type|#element-type>

=begin code :lang<raku>

my $matrix = Math::Matrix.new([[1,2],[3,4]]);
say $matrix.element(0,1)            : 2
say $matrix[0][1]                   # array syntax alias

=end code

=head3 L<AT-POS|#accessors>

Gets row as array to enable direct postcircumfix syntax as shown in last example.

=begin code :lang<raku>

say $matrix.AT-POS(0)     : [1,2]
say $matrix[0]            # operator alias
say $matrix.Array[0]      # long alias with converter method Array

=end code

=head3 L<row|#accessors>

returns the values of specified row (first required parameter) as a list.

=begin code :lang<raku>

say Math::Matrix.new([[1,2],[3,4]]).row(0) : (1, 2)

=end code

=head3 L<column|#accessors>

returns values of specified column (first required parameter) as a list.

=begin code :lang<raku>

say Math::Matrix.new([[1,2],[3,4]]).column(0) : (1, 3)

=end code

=head3 L<diagonal|#accessors>

Called without an argument, it returns the values of main diagonal as a list.
The main diagonal starts at the left upper corner (index [0][0]).  Every next cell
of the diagonal is reached by going one step below and one step to the right
(indices [x][x] - x being an integer within the size of the matrix).

Use the optional parameter of the method to get any other parallel diagonal.
A positive value for a parallel diagonale above and to the right of the main one -
a negative value to access a parallel diagonal to the left and below the
main diagonal. 0 is the default value.
The matrix does not have to be a quadratic (L<square|#is-square>).

=begin code :lang<raku>

say Math::Matrix.new([[1,2],[3,4]]      ).diagonal    : (1, 4)
say Math::Matrix.new([[1,2],[3,4]]      ).diagonal(1) : (2)
say Math::Matrix.new([[1,2],[3,4],[5,6]]).diagonal(-1): (3, 6)

=end code

=head3 L<skew-diagonal|#accessors>

Unlike a I<diagonal>, which runs from the left upper corner to the right lower,
the (main) skew diagonal is only defined for L<square|#is-square> matrixes and runs
from left lower corner to the right upper (from $matrix[m][0] to $matrix[0][m]).
Use the optional argument to get any other parallel skew diagonal.
Positive value for the ones below - negative above.

=begin code :lang<raku>

say $matrix.skew-diagonal    : (2, 3)
say $matrix.skew-diagonal(0) : (2, 3)
say $matrix.skew-diagonal(-1) : (1)
say $matrix.skew-diagonal(1): (4)

=end code

=head3 L<submatrix|#accessors>

Returns a matrix that might miss certain L<row|#row>s and columns of the original.
This method accepts arguments in three different formats. The first follows the strict
mathematical definition of a submatrix, the second supports a rather visual
understanding of the term and the third is a way to get almost any combination
rows and columns you might wish for. To properly present these functions,
we base the next examples upon this matrix:

=begin code :lang<raku>

say $m:    1 2 3 4
           2 3 4 5
           3 4 5 6
           4 5 6 7

=end code

=head4 L<leaving out one|#submatrix>

In mathematics, a submatrix is built by leaving out one L<row|#row> and one L<column|#column>.
In the two positional argument format you name these by their index ($row, $column).

=begin code :lang<raku>

say $m.submatrix(1,2) :    1 2 4
                           3 4 6
                           4 5 7

=end code

=head4 L<leaving out more|#submatrix>

If you provide two ranges (row-min .. row-max, col-min .. col-max - both optional)
to the appropriately named arguments, you get the excerpt of the matrix,
that contains only the requested rows and columns - in the original order.

=begin code :lang<raku>

say $m.submatrix( rows => 1..1, columns => 1..2) :    3 4
say $m.submatrix( rows => 1..1, columns => 2..*) :      4 5
say $m.submatrix( rows => 1..2 )                 :  2 3 4 5
                                                    3 4 5 6

=end code

=head4 L<reordering|#submatrix>

Alternatively each (as previously) named argument can also take a list (or array) of values,
as created my the sequence operator (...).
The result will be a matrix with that selection of rows and columns.
Please note, you may pick rows/columns in any order and as many times you prefer.

=begin code :lang<raku>

$m.submatrix(rows => (1,2), columns => (3,2)):    5 4
                                                  6 5

$m.submatrix(rows => (1...2), columns => (3,2))  # same thing

=end code

Arguments with ranges and lists can be mixed and are in both cases optional.
If you provide none of them, the result will be the original matrix.

=begin code :lang<raku>

say $m.submatrix( rows => (1,) )              :   3 4 5

$m.submatrix(rows => (1..*), columns => (3,2)):   5 4
                                                      6 5
=end code

Even more powerful or explicit in syntax are the L<structural ops|#structural-operations>.

=head2 L<Converter|#methods>

Methods that convert a matrix into other types: L<Bool|#bool>, L<Str|#str>, L<Numeric|#numeric>,
L<Range|#range>, L<Array|#array>, L<Hash|#hash>, L<list|#list>, L<list-rows|#list-rows>, L<list-columns|#list-columns>
or allow different views on the overall content (output formats): L<gist|#gist>, L<raku|#raku>.

=head3 L<Bool|#converter>

Conversion into Bool context. Returns False if matrix is zero
(all elements equal zero as in L<is-zero|#is-zero>), otherwise True.

=begin code :lang<raku>

$matrix.Bool
? $matrix           # alias op
if $matrix          # matrix in Bool context too

=end code

=head3 L<Str|#converter>

Returns values of all L<element|#element>s, separated by one whitespace, rows by new line.
This is the same format as expected by L<new("")|#new---2>.
Str is called implicitly by put and print. A shortened version is provided by L<gist|#gist>

=begin code :lang<raku>

say Math::Matrix.new([[1,2],[3,4]]).Str:

1 2                 # meaning: "1 2\n3 4"
3 4

~$matrix            # alias op

=end code

=head3 L<Numeric|#converter>

Conversion into Numeric context. Returns Euclidean L<norm|#norm>.
Please note, only a prefix operator + (as in: + $matrix) will call this Method.
An infix (as in $matrix + $number) calls $matrix.add($number).

=begin code :lang<raku>

$matrix.Numeric
+ $matrix           # alias op

=end code

=head3 L<Range|#converter>

Returns an range object that reflects the content of all L<element|#element>s.
Please note that complex number can not be endpoints of ranges.

=begin code :lang<raku>

say $matrix.Range: 1..4

=end code

To get single endpoints you could write:

=begin code :lang<raku>

say $matrix.Range.min: 1
say $matrix.list.max:  4

=end code

=head3 L<Array|#converter>

Content of all L<element|#element>s as an array of arrays (same format that was put into L<new([...])|#new-->).

=begin code :lang<raku>

say Math::Matrix.new([[1,2],[3,4]]).Array : [[1 2] [3 4]]
say @ $matrix       # alias op, space between @ and $ needed

=end code

=head3 L<list|#converter>

Returns a flat list with all L<element|#element>s (same as .list-rows.flat.list).

=begin code :lang<raku>

say $matrix.list    : (1 2 3 4)
say |$matrix        # alias op

=end code

=head3 L<list-rows|#converter>

Returns a list of lists, reflecting the row-wise content of the matrix.
Same format as L<new ()|#new---1> takes in.

=begin code :lang<raku>

say Math::Matrix.new( [[1,2],[3,4]] ).list-rows      : ((1 2) (3 4))
say Math::Matrix.new( [[1,2],[3,4]] ).list-rows.flat : (1 2 3 4)

=end code

=head3 L<list-columns|#converter>

Returns a list of lists, reflecting the row-wise content of the matrix.

=begin code :lang<raku>

say Math::Matrix.new( [[1,2],[3,4]] ).list-columns : ((1 3) (2 4))
say Math::Matrix.new( [[1,2],[3,4]] ).list-columns.flat : (1 3 2 4)

=end code

=head3 L<Hash|#converter>

Gets you a nested key - value hash.

=begin code :lang<raku>

say $matrix.Hash : { 0 => { 0 => 1, 1 => 2}, 1 => {0 => 3, 1 => 4} }
say % $matrix       # alias op, space between % and $ still needed

=end code

=head3 L<gist|#converter>

Limited tabular view, optimized for shell output. Just cuts off excessive
columns that do not fit into standard terminal and also stops after 20 rows.
If you call it explicitly, you can add width and height (char count) as optional arguments.
Might even not show all decimals. Several dots will hint that something is missing.
It is implicitly called by say. For a full view use L<Str|#str>.

=begin code :lang<raku>

say $matrix;      # output of a matrix with more than 100 elements

1 2 3 4 5 ..
3 4 5 6 7 ..
...

say $matrix.gist(max-chars => 100, max-rows => 5 );

=end code

max-chars is the maximum amount of characters in any L<row|#row> of output (default is 80).
max-rows is the maximum amount of rows gist will put out (default is 20).
After gist ist called once (with or without arguments) the output will be cached.
So next time you call:

=begin code :lang<raku>

say $matrix       # 100 x 5 is still the max

=end code

You change the cache by calling gist with arguments again.

=head3 L<raku|#converter>

Conversion into String that can reevaluated into the same object later using default constructor.

=begin code :lang<raku>

my $clone = $matrix.raku.EVAL;       # same as: $matrix.clone

=end code

=head2 L<Boolean Properties|#methods>

These are mathematical properties, a given matrix has or not.
Thus, the return value is a always of boolean type (Bool).
Arguments, like in case of L<triangular|#is-triangular> and
L<is-diagonally-dominant|#is-diagonally-dominant> are only necessary,
when a method can tell you about a group of closely related properties.

L<zero|#is-zero>, L<identity|#is-identity>, L<square|#is-square>,
B<L<triangular|#is-triangular>>: (L<upper|#upper-triangular>, L<lower|#lower-triangular>,
     L<strict|#strict-triangular>, L<unit|#unit-triangular>, L<atomic|#atomic-triangular>),
L<diagonal|#is-diagonal>, L<anti-diagonal|#is-anti-diagonal>, L<tridiagonal|#is-tridiagonal>,
L<diagonal-constant|#is-diagonal-constant>, L<catalecticant|#is-catalecticant>,
L<symmetric|#is-symmetric>, L<anti-symmetric|#is-antisymmetric>, L<self-adjoint|#is-self-adjoint>,
L<invertible|#is-invertible>, L<orthogonal|#is-orthogonal>, L<unitary|#is-unitary>,
B<L<diagonally-dominant|#is-diagonally-dominant>>,
L<positive-definite|#is-positive-definite>, L<positive-semidefinite|#is-positive-semidefinite>

=head3 L<is-zero|#boolean-properties>

True if every L<element|#element> has value of 0 (as created by L<new-zero|#new-zero>).
L<Density|#density> of zero matrices is 0.
This matrix behaves like a zero element regarding to the L<dot-product|#dot-product>.
Every matrix multiplied with a zero matrix is a zero matrix (A * 0 = 0 * A = 0).

=begin output

Example:    0 0 0
            0 0 0

=end output

=head3 L<is-identity|#boolean-properties>

True if every L<element|#element> on the main L<diagonal|#diagonal>
(where row index equals column index) is 1 and any other element is 0.
Such a matrix will be created by L<new-identity|#new-identity>.
It is the neutral element in redgards to the L<dot-product|#dot-product>. Every matrix
multiplied with a fitting identiy matrix results in the same matrix again (A * I = I * A = A).
Every identity matrix has to be a square.

=begin output

Example:    1 0 0
            0 1 0
            0 0 1

=end output

=head3 L<is-square|#boolean-properties>

True if number of rows and colums are the same (see L<size|#size>).

=head3 L<is-triangular|#boolean-properties>

L<square|#is-square> matrix where all L<element|#element>s above the main L<diagonal|#diagonal>
or all elements below the main diagonal are zero. The method accepts five optional, boolean arguments:
L<:upper|#upper-triangular>, L<:lower|#lower-triangula>, L<:strict|#strict-triangular>, L<:unit|#unit-triangular> and L<:atomic|#atomic-triangular>.
Each argument can be used in a positive form (I<:upper>), as a negative (I<:!upper>),
or omitted. Positively they demand a certain property, negatively the absence
or opposite. When omitted, both states are acceptable.

Please note that a triangular matrix can never be I<:unit> and I<:strict> or
I<:atomic> and I<:strict> at the same time, nor I<:!upper> and I<:!lower>.
A triangular matrix that is I<:upper> and I<:lower> L<is-diagonal|#is-diagonal>.
L<Identity|#is-identity> matrices are I<:upper>, I<:lower> and I<:unit>.

=head4 L<upper triangular|#is-triangular>

a.k.a I<right triangular matrix>: all L<element|#element>s left-below the main I<diagonal> are zero.
In other words: the L<lower-bandwith|#lower-bandwith> has to be zero.

=begin code :lang<raku>

$tri-matrix.is-triangular(:upper); # matrix in the example below would pass this test
$tri-matrix.is-triangular();       # True, there is a lower or upper triangle

Example:    1 2 5
            0 3 8
            0 0 7

=end code

=head4 L<lower triangular|#is-triangular>

a.k.a I<left triangular> matrix: every L<element|#element> right and above the L<diagonal|#diagonal>
(where L<row|#row> index is greater than L<column|#column> index) are zero.
In other words: the L<upper-bandwith|#upper-bandwith> has to be zero.

=begin code :lang<raku>

$tri-matrix.is-triangular(:lower);        # matrix in the example below would pass this test
$tri-matrix.is-triangular();              # True too
$tri-matrix.is-triangular(:!upper);       # True, because the is a triangle, but not an upper
$tri-matrix.is-triangular(:lower,:!upper);# True still, even a bit redundant

Example:    1 0 0
            2 3 0
            5 8 7

=end code

=head4 L<strict triangular|#is-triangular>

are I<triangular> matrices, that have a L<diagonal|#diagonal> consisting only of values equal zero.

=begin code :lang<raku>

$tri-matrix.is-triangular(:strict);       # matrix in the example below would pass this test
$tri-matrix.is-triangular(:!unit, :lower);# True too

Example:    0 0 0
            5 0 0
            0 6 0

=end code

=head4 L<unit triangular|#is-triangular>

a.k.a I<unitriangular> matrices have a L<diagonal|#diagonal> consisting only of values equal one.
An L<identity|#is-identity> matrix is I<:unit>, I<:upper> and I<:lower>.

=begin code :lang<raku>

$tri-matrix.is-triangular(:unit);         # matrix in the example below would pass this test
$tri-matrix.is-triangular(:unit, :lower); # False, because unit upper triangular

Example:    1 2 5
            0 1 8
            0 0 1

=end code

=head4 L<atomic triangular|#boolean-properties>

a.k.a I<Frobenius> matrix is a unit triangular matrix with one column of 'none zero values.

=begin code :lang<raku>

$tri-matrix.is-triangular(:atomic);        # matrix in the example below would pass this test

Example:    1 0 0 0
            0 1 0 0
            0 2 1 0
            0 5 0 1

=end code

=head3 L<is-diagonal|#boolean-properties>

L<square|#is-square> matrix, where only elements on the main L<diagonal|#diagonal> differ from 0
(as created by L<new-diagonal|#new-diagonal>).

=begin code :lang<raku>

$tri-matrix.is-diagonal();
$tri-matrix.is-triangular(:upper, :lower); # same thing
$tri-matrix.lower-bandwith() == $tri-matrix.upper-bandwith() == 0; # True

Example:    1 0 0
            0 5 0
            0 0 9

=end code

=head3 L<is-anti-diagonal|#boolean-properties>

L<square|#is-square> matrix, where only elements on the main L<skew-diagonal|#skew-diagonal> differ from 0.

=begin code :lang<raku>

$tri-matrix.is-anti-diagonal();

Example:    0 0 3
            0 5 0
            7 0 0

=end code

=head3 L<is-tridiagonal|#boolean-properties>

L<square|#is-square> matrix, where only elements on the main L<diagonal|#diagonal>
and their direct parallels differ from 0.

=begin code :lang<raku>

$tri-matrix.is-tridiagonal();
$tri-matrix.lower-bandwith() < 2 and $tri-matrix.upper-bandwith() < 2; # True

Example:    1 2 0 0
            3 4 5 0
            0 6 7 8
            0 0 9 1

=end code

=head3 L<is-diagonal-constant|#boolean-properties>

a.k.a. or I<Töplitz> matrix is a matrix where every L<diagonal|#diagonal>
is the a collection of L<element|#element>s that hold the same value.

=begin output

    Example:     0  1  2
                -1  0  1
                -2 -1  0

=end output

=head3 L<is-catalecticant|#boolean-properties>

a.k.a I<Hankel> matrix is a L<square|#is-square> matrix, where every L<skew-diagonal|#skew-diagonal>
is the a collection of L<element|#element>s that hold the same value.
I<Catalecticant> matrices are L<symmetric|#is-symmetric>.

=begin output

Example:     0  1  2
             1  2  3
             2  3  4

=end output

=head3 L<is-symmetric|#boolean-properties>

True if every L<element|#element> with coordinates x y has same value as the element on y x.
In other words: $matrix and $matrix.L<transposed|#transposed> (alias T) are the same.

=begin output

Example:    1 2 3
            2 5 4
            3 4 7

=end output

=head3 L<is-antisymmetric|#boolean-properties>

Means the L<transposed|#transposed> and L<negated|#negated> matrix are the same.

=begin output

Example:    0  2  3
           -2  0  4
           -3 -4  0

=end output

=head3 L<is-self-adjoint|#boolean-properties>

A Hermitian or self-adjoint matrix is L<equal|#equal> to its L<transposed|#transposed> and complex L<conjugated|#conjugated>.

=begin output

Example:    1   2   3+i
            2   5   4
            3-i 4   7

=end output

=head3 L<is-invertible|#boolean-properties>

, also called I<nonsingular> or I<nondegenerate>, is a L<square|#is-square> matrix,
which has a none zerot L<determinant|#determinant>. That means all rows or colums
have to be independent vectors. Please check this property before calling
$matrix.L<inverted|#inverted>, or you will get an exception.

=head3 L<is-orthogonal|#boolean-properties>

An orthogonal matrix multiplied (L<dot-product|#dot-product>) with its transposed derivative (T)
is an L<identity|#is-identity> matrix or in other words: L<transposed|#transposed> and L<inverted|#inverted> matrices are L<equal|#equal>.

=head3 L<is-unitary|#boolean-properties>

An unitery matrix multiplied (L<dot-product|#dot-product>) with its L<concjugated|#conjugated>
and transposed derivative (.conj.T) is an L<identity|#is-identity> matrix, or said differently:
the concjugate transposed matrix equals the L<inverted|#inverted> matrix.

=head3 L<is-diagonally-dominant|#boolean-properties>

True when L<element|#element>s on the L<diagonal|#diagonal> have a bigger (if strict) or at least equal (in none strict)
absolute value than the sum of its row (sum of absolute values of the row except diagonal element).

=begin code :lang<raku>

if $matrix.is-diagonally-dominant {
$matrix.is-diagonally-dominant(:!strict)      # same thing (default)
$matrix.is-diagonally-dominant(:strict)       # diagonal elements (DE) are stricly greater (>)
$matrix.is-diagonally-dominant(:!strict, :along<column>) # default
$matrix.is-diagonally-dominant(:strict,  :along<row>)    # DE > sum of rest row
$matrix.is-diagonally-dominant(:!strict, :along<both>)   # DE >= sum of rest row and rest column

=end code

=head3 L<is-positive-definite|#boolean-properties>

True if all main L<minors|#minor> or all Eigenvalues are strictly greater zero.

=head3 L<is-positive-semidefinite|#boolean-properties>

True if all main L<minors|#minor> or all Eigenvalues are greater equal zero.

=head2 L<Numeric Properties|#methods>

Matrix properties that are expressed with a single number, which will be calculated without further input.

L<size|#size>, L<density|#density>, B<L<bandwith|#bandwith>>: (L<lower-|#lower-bandwith>, L<upper-|#upper-bandwith>), L<trace|#trace>, L<rank|#rank>, L<nullity|#nullity>,
L<determinant|#determinant>, L<minor|#minor>, L<norm|#norm>, L<condition|#condition>, B<L<element-type|#element-type>>:
(L<narrowest-|#narrowest-element-type>, L<widest-|#widest-element-type>)

=head3 L<size|#numeric-properties>

List of two values: number of rows and number of columns.

=begin code :lang<raku>

say $matrix.size();
my $dim = min $matrix.size;

=end code

=head3 L<density|#numeric-properties>

I<Density> is the percentage of L<element|#element>s which are not zero. I<sparsity> = 1 - I<density>.

=begin code :lang<raku>

my $d = $matrix.density;

=end code

=head3 L<bandwith|#numeric-properties>

Is roughly the greatest distance of a none zero value from the main L<diagonal|#diagonal>.
A matrix that L<is-diagonal|#is-diagonal> has a bandwith of 0. If there is a none zero
value on an diagonal above or below the main diagonal, tha bandwith would be one.

=begin code :lang<raku>

my $bw = $matrix.bandwith;

=end code

=head4 L<lower-bandwith|#bandwith>

In a matrix with the lower bandwith of k, every L<element|#element> with row index m and column index n,
for which holds m - k > n, the content has to be zero. Literally speaking: there are k L<diagonal|#diagonal>s
below the main diagonal, that contain none zero values.

=head4 L<upper-bandwith|#bandwith>

Analogously, every L<element|#element> with m + k < n is zero if matrix has an upper bandwith of k.
=begin output

Example:    1  0  0
            4  2  0
            0  5  3

=end output

The I<bidiagonal> example matrix has an upper bandwith of zero and lower bandwith of one, so the overall bandwith is one.

=head3 L<trace|#numeric-properties>

The trace of a L<square|#is-square> matrix is the sum of the L<element|#element>s on the main diagonal.
In other words: sum of elements which row and column value is identical.

=begin code :lang<raku>

my $tr = $matrix.trace;

=end code

=head3 L<rank|#numeric-properties>

Rank is the number of independent row or column vectors or also called independent
dimensions (thats why this command is sometimes calles dim)

=begin code :lang<raku>

my $r = $matrix.rank;

=end code

=head3 L<nullity|#numeric-properties>

Nullity of a matrix is the number of dependent rows or columns (rank + nullity = dim).
Or number of dimensions of the kernel (vector space mapped by the matrix into zero).

=begin code :lang<raku>

my $n = $matrix.nullity;

=end code

=head3 L<determinant|#numeric-properties>

Only a L<square|#is-square> matrice has a defined determinant,
which tells the volume, spanned by the row or column vectors.
So if the volume is just in one dimension flat, the determinant is zero,
and has a kernel (not a full L<rank|#rank> - thus is not L<invertible|#is-invertable>).

=begin code :lang<raku>

my $det = $matrix.determinant;
my $d = $matrix.det;                # same thing
my $d = ❘ $matrix ❘;                # unicode operator shortcut

=end code

=head3 L<minor|#numeric-properties>

A Minor is the determinant of a L<submatrix|#leaving-out-one> (first variant with same 2 scalar arguments a minor method).
The two required positional arguments are row and column indices of an existing L<element|#element>.

=begin code :lang<raku>

my $m = $matrix.minor(1,2);

=end code

=head3 L<norm|#numeric-properties>

A norm is a single positive number, which is an abstraction to the concept of size.
Most common form for matrices is the p-norm, where in step 1
the absolute value of every L<element|#element> is taken to the power of p.
The sum of these results is taken to the power of 1/p.
The p-q-Norm extents this process. In his step 2 every column-sum is taken to the power of (p/q).
In step 3 the sum of these are taken to the power of (1/q).

=begin code :lang<raku>

my $norm = $matrix.norm( );           # euclidian norm aka L2 (p = 2, q = 2)
my $norm = + $matrix;                 # context op shortcut
my $norm = ‖ $matrix ‖;               # unicode op shortcut
my $norm = $matrix.norm(1);           # p-norm aka L1 = sum of all elements absolute values (p = 1, q = 1)
my $norm = $matrix.norm(p:<4>,q:<3>); # p,q - norm, p = 4, q = 3
my $norm = $matrix.norm(p:<2>,q:<2>); # L2 aka Euclidean aka Frobenius norm
my $norm = $matrix.norm('euclidean'); # same thing, more expressive to some
my $norm = $matrix.norm('frobenius'); # same thing, more expressive to some
my $norm = $matrix.norm('max');       # maximum norm - biggest absolute value of a element
$matrix.norm('row-sum');              # row sum norm - biggest abs. value-sum of a row
$matrix.norm('column-sum');           # column sum norm - same column wise

=end code

=head3 L<condition|#numeric-properties>

Condition number of a matrix is L2 norm * L2 of L<inverted|#inverted> matrix.

=begin code :lang<raku>

my $c = $matrix.condition( );

=end code

=head3 L<element-type|#numeric-properties>

=head4 L<narrowest-element-type|#numeric-properties>

=head4 L<widest-element-type|#numeric-properties>

Matrix L<element|#element>s can be (from most narrow to widest), of type (Bool), (Int), (Num), (Rat), (FatRat) or (Complex).
The widest type of any element will returned as type object.

In the next example the smartmatch returns true, because no element of our default example matrix has wider type
than (Int). After such a test all elements can be safely treated as Int or Bool.

=begin code :lang<raku>

if $matrix.widest-element-type ~~ Int { ...

=end code

You can also check if all elements have the same type:

=begin code :lang<raku>

if $matrix.widest-element-type eqv $matrix.narrowest-element-type

=end code

=head2 L<Derived Matrices|#methods>

Single matrices, that can be computed with only our original matrix as input.

L<transposed|#transposed>, L<negated|#negated>, L<conjugated|#conjugated>, L<adjugated|#adjugated>,
L<inverted|#inverted>, L<reduced-row-echelon-form|#reduced-row-echelon-form>

=head3 L<transposed|#derived-matrices>

Returns a new, transposed Matrix, where rows became colums and vice versa.

=begin code :lang<raku>

Math::Matrix.new([[1,2,3],[3,4,6]]).transposed :

[[1 2 3]     = [[1 4]
 [4 5 6]].T     [2 5]
                [3 6]]

Math::Matrix.new([[1,2,3],[3,4,6]]).T # same but shorter

=end code

=head3 L<negated|#derived-matrices>

Creates a matrix where every L<element|#element> has the negated value of the original (invertion of sign).

=begin code :lang<raku>

my $new = $matrix.negated();     # invert sign of all elements
my $neg = - $matrix;             # operator alias

say $neg:  -1 -2
           -3 -4

=end code

=head3 L<conjugated|#derived-matrices>

Creates a matrix where every L<element|#element> is the complex conjugated of the original.

=begin code :lang<raku>

my $c = $matrix.conjugated();    # change every value to its complex conjugated
my $c = $matrix.conj();          # short alias (official Raku shortcut for conjugation of numbers)

say Math::Matrix.new([[1+i,2],[3,4-i]]).conj :

1-1i  2
3     4+1i

my $ct = $matrix.H;              # conjugated and transposed matrix (Hermitian transpose)

=end code

=head3 L<adjugated|#derived-matrices>

Creates a matrix out of the properly signed L<minors|#minor> of the original.
It is called adjugate, classical adjoint or sometimes adjunct.

=begin code :lang<raku>

$matrix.adjugated.say :

 4 -3
-2  1

=end code

=head3 L<inverted|#derived-matrices>

Matrices that have a L<square|#is-square> form and a full L<rank|#rank> can be L<inverted|#inverted> (see L<is-invertible|#is-invertible>).
Inverse matrix regarding to matrix multiplication (see L<dot-product|#dot-product>).
The dot product of a matrix with it's inverted results in a L<identity|#is-identity> matrix
(neutral element in this group).

=begin code :lang<raku>

my $i = $matrix.inverted();      # invert matrix
my $i = $matrix ** -1;           # operator alias

say $i:

 -2    1
1.5 -0.5

=end code

=head3 L<reduced-row-echelon-form|#derived-matrices>

Return the reduced row echelon form of a matrix, a.k.a. row canonical form

=begin code :lang<raku>

my $rref = $matrix.reduced-row-echelon-form();
my $rref = $matrix.rref();       # short alias

=end code

=head2 L<Decompositions|#methods>

Methods that return a list of matrices, which can be recombined into the original matrix
(mostly by L<dot product|#dot-product>).

L<LU|#LU-decomposition>,
L<LU-Crout|#LU-Crout-decomposition>,
L<LDU|#LDU-decomposition>,
L<LUP|#LUP-decomposition>,
L<Cholesky|#Cholesky-decomposition>
L<LDL|#LDL-decomposition>

=head3 L<LU-decomposition|#decompositions>

Decompose an L<invertible|#is-invertible>, matrix into a L<lower triangular|#is-lower-triangular> (called L)
and an L<upper triangular matrix|#is-upper-triangular> (called U).
The algorithm works along the lines of what is called Gaussian elimination.

=begin code :lang<raku>

my ($L, $U) = $matrix.LU-decomposition();
$L dot $U eq $matrix;                # True
$U.is-triangular(:upper);             # True
$L.is-triangular(:lower, :unit);       # True

=end code

=head4 L<LU-Crout-decomposition|#decompositions>

L will also be L<unit triangular matrix|#unit-triangular>, but not U - meaning
the L<diagonal|#diagonal> elements of L are all equal 1 and the diagonal elements of U
might differ from 1. If you prefer this to be the other way around, use the optional,
boolean parameter I<:Crout>.

=begin code :lang<raku>

my ($L, $U) = $matrix.LU-decomposition(:Crout);
$L dot $U eq $matrix;                # True
$L.is-triangular(:lower);             # True
$U.is-triangular(:upper, :unit);       # True

=end code

=head4 L<LDU-decomposition|#decompositions>

If you want the diagonal elements separated into its own matrix, use the optional, boolean
parameter I<:diagonal>. Note that you can not use this and I<:Crout> at once.

=begin code :lang<raku>

my ($L, $D, $U) = $matrix.LU-decomposition( :diagonal);
$L dot $D dot $U eq $matrix;         # True
$L.is-triangular(:lower, :unit);      # True
$U.is-triangular(:upper, :unit);       # True
$D.is-diagonal();                       # True

=end code

=head4 L<LUP-decomposition|#decompositions>

If you choose the optional, boolean parameter I<:pivot>, you get additionally a permutation
matrix, that contains the information which rows and columns were swapped, in order to achieve
a decomposition. That is why the matrix no longer has to be L<invertible|#is-invertable>,
but only L<square|#is-square> to run a LU decomposition with permutation.
This option might be combined with I<:Crout> or I<:diagonal>, but not both.

=begin code :lang<raku>

my ($L, $U, $P) = $matrix.LU-decomposition( :pivot );
$L dot $U eq $matrix dot $P;         # True

=end code

=head3 L<Cholesky-decomposition|#decompositions>

This decomposition does roughly the same as LU and is faster.
But it works only on matrices that are L<symmetric|#is-symmetric> and L<positive-definite|#is-positive-definite>.
The result will be an L<orthogonal|#is-orthogonal>,
L<lower triangular matrix|#is-lower-triangular> matrix (here called G)
that multiplied with its L<transposed|#transposed> gives you the original matrix.

=begin code :lang<raku>

my $G = $matrix.Cholesky-decomposition( );          # $G is a left triangular matrix
my $G = $matrix.Cholesky-decomposition(:!diagonal); # same as before
$G dot $G.T == $matrix;                             # True

=end code

=head4 L<LDL-decomposition|#decompositions>

When the optional, boolean parameter :diagonal is positive (negative by default)
you get two matrices (L and D) as a result. L is then a L<lower unit triangular matrix|#unit-triangular>,
(with ones in its main diagonal). D is a L<diagonal|#diagonal> matrix ( G = L * sqrt(D)),
containing the values formerly on the diagonal of G, but squared.
This output format is also known as I<LDL decomposition>.
You get the second L matrix easily by transposing the L you got.

=begin code :lang<raku>

my ($L, $D) = $matrix.Cholesky-decomposition(:diagonal);
$L dot $D dot $L.T == $matrix;                      # True

=end code

=head2 L<Mathematical Operations|#methods>

Math methods that work on a whole matrix or just some parts of it.
The operands will not be changed but a the result matrix will be returned.

L<equal|#equal>, B<L<add|#add>>: (L<matrix|#add-matrix>, L<vector|#add-vector>, L<scalar|#add-scalar>),
B<L<multiply|#multiply>>: (L<matrix|#multiply-matrix>, L<vector|#multiply-vector>, L<scalar|#multiply-scalar>), L<dot-product|#dot-product>, L<tensor-product|#tensor-product>.

=head3 L<equal|#mathematical-operations>

Checks two matrices for equality. They have to be of same L<size|#size> and every L<element|#element>
of the first matrix on a particular position has to be numerically equal (as checked by I<==>) to the element
(on the same position) of the second matrix.

=begin code :lang<raku>

if $matrixa.equal( $matrixb ) {   # method variant
if $matrixa == $matrixb {         # operator alias
if $matrixa ~~ $matrixb {         # smart match redirects to ==

=end code

=head3 L<add|#mathematical-operations>

Adding a matrix, L<vector|#add-vector> or L<scalar|#scalar-scalar>.
Named arguments I<:row> and I<:column> are only used to add a vector (one) or scalar (both).

=head4 L<add matrix|#add>

When adding two matrices, they have to be of the same L<size|#size>.
Instead of a Math::Matrix object you can also provide the content of a matrix as
L<new []|#new-->, L<new ()|#new---1> or L<new ""|#new---2> would accept it.

=begin code :lang<raku>

$matrix.add( $matrix2 );
$matrix.add( [[2,3],[4,5]] ); # data alias
$matrix + $matrix2            # operator alias

Example:    1 2  +  2 3  =  3 5
            3 4     4 5     7 9

=end code

=head4 L<add vector|#add>

To add a vector you have to specify to which row or column it should be added.
The other argument is a list or array (which have to fit the row or column size).

=begin code :lang<raku>

$matrix.add( row => 1, [2,3] );

Example:    1 2  +       =  1 2
            3 4    2 3      5 7

$matrix.add( column => 1, (2,3) );

Example:    1 2  +   2   =  1 4
            3 4      3      3 7

=end code

=head4 L<add scalar|#add>

When adding a single number to the matrix (providing one argument),
the number will be added to every L<element|#element> of the matrix.
If you additionally provide a row or column number, only in that row or column,
every element gets added to.
In case you provide row and column numbber (three args), only a single element
of the result matrix might be different.

=begin code :lang<raku>

$matrix.add( $number );       # adds number to every element
$matrix + $number;            # works too

Example:    1 2  +  5    =  6 7
            3 4             8 9

$matrix.add( row => 1, 3 ):             [[1,2],[6,7]]
$matrix.add( row => 1, column=> 0, 2 ): [[1,2],[5,4]]

=end code

=head3 L<multiply|#mathematical-operations>

Unlike the L<dot-product|#dot-product> and L<tensor-product|#tensor-product>,
this operation is the simple, scalar multiplication applied to each ore some L<element|#element>s.
The second factor might come from the cells of another L<matrix|#multiply-matrix>,
a L<vector|#multiply-vector> or a L<single value|#multiply-scalar>.
That is why this method works analogous to L<add|#add>.

=head4 L<multiply matrix|#multiply>

When a matrix of same size is given, the result will be a matrix
of that size again. Each element will be the product of two the two elements of the
operands with the same indices (position).
Instead of a Math::Matrix object you can also provide the content of a matrix as
L<new []|#new-->, L<new ()|#new---1> or L<new ""|#new---2> would accept it.

=begin code :lang<raku>

my $product = $matrix.multiply( $matrix2 );  # element wise multiplication of same size matrices
my $p = $matrix * $matrix2;                  # works too

Example:    1 2  *  2 3  =   2  6
            3 4     4 5     12 20

=end code

=head4 L<multiply vector|#multiply>

Takes a vector (list of numbers) and a Pair thst specifies an existing row or column.
This row or column will than multiplied with the vector
(element one by vector element one, and so on).

=begin code :lang<raku>

my $product = $matrix.multiply( row => 0, (2, 3) );   # multiply every element with number

Example:    1 2  *  2 3  =  2 6
            3 4             3 4

=end code

=head4 L<multiply scalar|#multiply>

If you provide just one number, every matrix element will be multiplied by this number.
When you additionally add a valid row or column index, only the cells in that row or
column get multiplied. (This is especially useful, when doing Gaussian elimination.)
If both are provided, only one cell gets multiplied.

=begin code :lang<raku>

my $product = $matrix.multiply( $number );   # multiply every element with number
my $p = $matrix * $number;                   # does the same

Example:    1 2  *  5    =   5 10
            3 4             15 20

$matrix.multiply( row => 0, 2);

Example:    1 2  * 2     =  2 4
            3 4             3 4

$matrix.multiply(2, column => 0 );

Example:    1 2   =  2 2
            3 4      6 4

           *2

$matrix.multiply(row => 1, column => 1, 3) : [[1,2],[3,12]]

=end code

=head3 L<dot-product|#mathematical-operations>

Matrix multiplication of two fitting matrices (colums left == rows right).

=begin code :lang<raku>

Math::Matrix.new( [[1,2],[3,4]] ).dot-product(  Math::Matrix.new([[2,3],[4,5]]) );

Example:    2  3
            4  5
         *
     1 2   10 13  =  1*2+2*4  1*3+2*5
     3 4   22 29     3*2+4*4  3*3+4*5

my $product = $matrix1.dot-product( $matrix2 )
my $c = $a dot $b;              # works too as operator alias
my $c = $a ⋅ $b;                # unicode operator alias

A shortcut for multiplication is the power - operator **
my $c = $a **  3;               # same as $a dot $a dot $a
my $c = $a ** -3;               # same as ($a dot $a dot $a).inverted
my $c = $a **  0;               # created an right sized identity matrix

=end code

=head3 L<tensor-product|#mathematical-operations>

The I<tensor product> (a.k.a I<Kronecker product>) between a matrix A of I<size|#size> (m,n)
and matrix B of size (p,q) is a matrix C of size (m*p,n*q).
C is a concatination of matrices you get if you take every L<element|#element> of A
and do a L<scalar multiplication|#multiply> with B as in $B.multiply($A.element(..,..)).

=begin code :lang<raku>

Example:    1 2  X*  2 3   =  1*[2 3] 2*[2 3]  =  2  3  4  6
            3 4      4 5        [4 5]   [4 5]     4  5  8 10
                              3*[2 3] 4*[2 3]     6  9  8 12
                                [4 5]   [4 5]     8 15 16 20

my $c = $matrixa.tensor-product( $matrixb );
my $c = $a X* $b;               # works too as operator alias
my $c = $a ⊗ $b;                # unicode operator alias

=end code

=head2 L<List Like Operations|#methods>

Methods (or extensions thereof) that usually are provided by Lists and Arrays,
but make also sense in context of matrices:
 L<elems|#elems>, L<elem|#elem>, L<cont|#cont>, L<map|#map>, L<map-with-index|#map-with-index>,
 L<reduce|#reduce>, L<reduce-rows|#reduce-rows>, L<reduce-columns|#reduce-columns>

=head3 L<elems|#list-like-operations>

Number (count) of L<element|#element>s = rows * columns (see L<size|#size>).

=begin code :lang<raku>

say $matrix.elems();

=end code

=head3 L<elem|#list-like-operations>

Asks if all L<element|#element> of Matrix (cell) values are an element of the given set or range.

=begin code :lang<raku>

Math::Matrix.new([[1,2],[3,4]]).elem(1..4) :   True
Math::Matrix.new([[1,2],[3,4]]).elem(2..5) :   False, 1 is not in 2..5

=end code

=head3 L<cont|#list-like-operations>

Asks if the matrix contains a value equal to the only argument of the method.
If a range is provided as argument, at least one value has to be
within this range to make the result true.

=begin code :lang<raku>

Math::Matrix.new([[1,2],[3,4]]).cont(1)   : True
Math::Matrix.new([[1,2],[3,4]]).cont(5)   : False
Math::Matrix.new([[1,2],[3,4]]).cont(3..7): True

MM [[1,2],[3,4]] (cont) 1                 # True too

=end code

=head3 L<map|#list-like-operations>

Creates a new matrix of same size by iterating over all or some L<element|#element>s.
For every chosen element with the indices (m,n),
a provided code block (required argument) will be run once.
That block will be given the elements(m,n) value as an argument.
The return value of the block will be the content of the element(m,n) of the resulting matrix.

=begin code :lang<raku>

say $matrix.map(* + 1) :

2 3
4 5

=end code

By provding values (Ranges) to the named arguments I<rows> and I<columns> (no special order required),
only a subset of rows or columns will be mapped - the rest will be just copied.

=begin code :lang<raku>

say $matrix.map( rows => (0..0), {$_ * 2}) :

2 4
3 4

say $matrix.map( rows => (1..*), columns => (1..1), {$_ ** 2}) :

1  2
3 16

=end code

=head3 L<map-with-index|#list-like-operations>

Works just like L<map|#map> with the only difference that the given block
can recieve one to three arguments: (row index, column index and cell value).

=begin code :lang<raku>

say $matrix.map-with-index: {$^m == $^n ?? $^value !! 0 } :

1 0
0 4

=end code

=head3 L<reduce|#list-like-operations>

Like the built in reduce method, it iterates over all L<element|#element>s and joins
them into one value, by applying the given operator or method
to the previous result and the next element. I starts with the element [0][0]
and moving from left to right in the first row and continue with the first
element of the next row.

=begin code :lang<raku>

Math::Matrix.new([[1,2],[3,4]]).reduce(&[+]): 10 = 1 + 2 + 3 + 4
Math::Matrix.new([[1,2],[3,4]]).reduce(&[*]): 10 = 1 * 2 * 3 * 4

=end code

=head3 L<reduce-rows|#list-like-operations>

Reduces (as described above) every row into one value, so the overall result
will be a list. In this example we calculate the sum of all elements in a row:

=begin code :lang<raku>

say Math::Matrix.new([[1,2],[3,4]]).reduce-rows(&[+]): (3, 7)

=end code

=head3 L<reduce-columns|#list-like-operations>

Similar to reduce-rows, this method reduces each column to one value in the
resulting list:

=begin code :lang<raku>

say Math::Matrix.new([[1,2],[3,4]]).reduce-columns(&[*]): (3, 8)

=end code


=head2 L<Structural Operations|#methods>

Methods that reorder rows and columns, delete some or even add new.
The accessor L<submatrix|#submatrix> is also useful for that purpose.
L<move-row|#move-row>, L<move-column|#move-column>, L<swap-rows|#swap-rows>, L<swap-rows|#swap-columns>,
L<splice-rows|#splice-rows>, L<splice-columns|#splice-columns>

=head3 L<move-row|#structural-matrix-operations>

=begin code :lang<raku>

Math::Matrix.new([[1,2,3],[4,5,6],[7,8,9]]).move-row(0,1);  # move row 0 to 1
Math::Matrix.new([[1,2,3],[4,5,6],[7,8,9]]).move-row(0=>1); # same

1 2 3           4 5 6
4 5 6    ==>    1 2 3
7 8 9           7 8 9

=end code

=head3 L<move-column|#structural-matrix-operations>

=begin code :lang<raku>

Math::Matrix.new([[1,2,3],[4,5,6],[7,8,9]]).move-column(2,1);
Math::Matrix.new([[1,2,3],[4,5,6],[7,8,9]]).move-column(2=>1); # same

1 2 3           1 3 2
4 5 6    ==>    4 6 5
7 8 9           7 9 8

=end code

=head3 L<swap-rows|#structural-matrix-operations>

=begin code :lang<raku>

Math::Matrix.new([[1,2,3],[4,5,6],[7,8,9]]).swap-rows(2,0);

1 2 3           7 8 9
4 5 6    ==>    4 5 6
7 8 9           1 2 3

=end code

=head3 L<swap-columns|#structural-matrix-operations>

=begin code :lang<raku>

Math::Matrix.new([[1,2,3],[4,5,6],[7,8,9]]).swap-columns(0,2);

1 2 3           3 2 1
4 5 6    ==>    6 5 4
7 8 9           9 8 7

=end code

=head3 L<splice-rows|#structural-matrix-operations>

Like the splice for lists: the first two parameter are position and amount (optional) of rows to be deleted.
The third and alos optional parameter will be an array of arrays (line .new would accept),
that fitting row lengths. These rows will be inserted before the row with the number of first parameter.
The third parameter can also be a fitting Math::Matrix.

=begin code :lang<raku>

$matrix.splice-rows(0,0, Math::Matrix.new([[5,6],[7,8]]) ); # aka prepend
$matrix.splice-rows(0,0,                  [[5,6],[7,8]]  ); # same result

5 6
7 8
1 2
3 4

$matrix.splice-rows(1,0, Math::Matrix.new([[5,6],[7,8]]) ); # aka insert
$matrix.splice-rows(1,0,                  [[5,6],[7,8]]  ); # same result

1 2
5 6
7 8
3 4

$matrix.splice-rows(1,1, Math::Matrix.new([[5,6],[7,8]]) ); # aka replace
$matrix.splice-rows(1,1,                  [[5,6],[7,8]]  ); # same result

1 2
5 6
7 8

$matrix.splice-rows(2,0, Math::Matrix.new([[5,6],[7,8]]) ); # aka append
$matrix.splice-rows(2,0,                  [[5,6],[7,8]]  ); # same result
$matrix.splice-rows(-1,0,                 [[5,6],[7,8]]  ); # with negative index

1 2
3 4
5 6
7 8

=end code

=head3 L<splice-columns|#structural-matrix-operations>

Same as splice-rows, just horizontally.

=begin code :lang<raku>

$matrix.splice-columns(2,0, Math::Matrix.new([[5,6],[7,8]]) ); # aka append
$matrix.splice-columns(2,0,                  [[5,6],[7,8]]  ); # same result
$matrix.splice-columns(-1,0,                 [[5,6],[7,8]]  ); # same result with negative index

1 2  ~  5 6  =  1 2 5 6
3 4     7 8     3 4 7 8

=end code

=head2 L<Shortcuts|#methods>

Summary of all shortcut aliases (left) and their long form (right).

=item T  -->  L<transposed|#transposed>
=item H --> L<conjugated and transposed|#conjugated>
=item conj  -->  L<conjugated|#conjugated>
=item det  -->  L<determinant|#determinant>
=item rref  -->  L<reduced-row-echelon-form|#reduced-row-echelon-form>

=head2 L<Operator Methods|#methods>

Operators (left) with the methods they refer to (right). (Most ops are just aliases.)
For more explanations of the ops (with examples) see the L<next chapter|#operators>:

=item prefix ?  -->  L<Bool|#bool>
=item prefix +  -->  L<Numeric|#numeric>
=item prefix -  -->  L<negated|#negated>
=item prefix ~  -->  L<Str|#str>
=item prefix |  -->  L<list|#list>
=item prefix @  -->  L<Array|#array>
=item prefix %  -->  L<Hash|#hash>
=item prefix MM  -->  L<new|#new-->
=item infix ==  -->  L<equal|#equal>
=item infix ~~  -->  L<equal|#equal> ACCEPTS
=item infix +  -->  L<add|#add>
=item infix -  -->  L<add|#add>
=item infix *  -->  L<multiply|#multiply>
=item infix ⋅ dot  -->  L<dot-product|#dot-product>
=item infix ÷  -->  dot-product L<inverted|#inverted>
=item infix **  -->  dot-product inverted
=item infix ⊗ X*  -->  L<tensor-product|#tensor-product>
=item circumfix ｜..｜ -->  L<determinant|#determinant>
=item circumfix ‖..‖  -->  L<norm|#norm>
=item postcircumfix [..]  -->  L<AT-POS|#at-pos>

=head1 L<Operators|#synopsis>

The Module overloads or introduces a range of well and lesser known ops, which are almost all L<aliases|#operator-methods>.

==, +, * are commutative, -, ⋅, dot, ÷, x, ⊗ and ** are not.
All ops have same precedence as its multi method siblings - unless stated otherwise.

They are exported when using no flag (same as :DEFAULT) or :ALL, but not under :MANDATORY or :MM).
The only exception is MM operator, a shortcut to create a matrix.
That has to be importet explicitly with the tag :MM or :ALL.
The postcircumfix [] - op will always work.

=begin code :lang<raku>

my $a   = +$matrix               # Num context, Euclidean norm
my $b   = ?$matrix               # Bool context, True if any element has a none zero value
my $str = ~$matrix               # String context, matrix content, space and new line separated as table
my $l   = |$matrix               # list context, list of all elements, row-wise
my $a   = @ $matrix              # same thing, but as Array
my $h   = % $matrix              # hash context, similar to .kv, so that %$matrix{0}{0} is first element

$matrixa == $matrixb             # check if both have same size and they are element wise equal
$matrixa ~~ $matrixb             # same thing

my $sum =  $matrixa + $matrixb;  # element wise sum of two same sized matrices
my $sum =  $matrix  + $number;   # add number to every element

my $dif =  $matrixa - $matrixb;  # element wise difference of two same sized matrices
my $dif =  $matrix  - $number;   # subtract number from every element
my $neg = -$matrix               # negate value of every element

my $p   =  $matrixa * $matrixb;  # element wise product of two same sized matrices
my $sp  =  $matrix  * $number;   # multiply number to every element

my $dp  =  $a dot $b;            # dot product of two fitting matrices (cols a = rows b)
my $dp  =  $a ⋅ $b;              # dot product, unicode (U+022C5)
my $dp  =  $a ÷ $b;              # alias to $a dot $b.inverted, (U+000F7)

my $c   =  $a **  3;             # $a to the power of 3, same as $a dot $a dot $a
my $c   =  $a ** -3;             # alias to ($a dot $a dot $a).inverted
my $c   =  $a **  0;             # creates an right sized identity matrix

my $tp  =  $a X* $b;             # tensor product, same precedence as infix: x (category Replication)
my $tp  =  $a ⊗ $b;              # tensor product, unicode (U+02297)

 ｜$matrix ｜                     # determinant, unicode (U+0FF5C)
 ‖ $matrix ‖                     # L2 norm (euclidean p=2 to the square), (U+02016)

   $matrix[1][2]                 # 2nd row, 3rd column element - works even under :MANDATORY tag

MM [[1]]                         # a new matrix, has higher precedence than postcircumfix:[]
MM '1'                           # string alias

=end code

=head1 L<Export Tags|#synopsis>

=item :MANDATORY (nothing is exported)
=item :DEFAULT (same as no tag, most L<ops|#operators> will be exported)
=item :MM (only L<MM|#new--> op exported)
=item :ALL

=head1 L<Authors|#synopsis>

=item Pierre Vigier
=item Herbert Breunung

=head1 L<Contributors|#synopsis>

=item Patrick Spek
=item Juan Julián Merelo Guervós

=head1 L<License|#synopsis>

Copyright 2015 - 2020 Pierre Vigier, Herbert Breunung

Copyright 2024 The Raku Community

This library is free software; you can redistribute it and/or modify it under the Artistic License 2.0.

=head1 L<See Also|#synopsis>

=item Math::Libgsl::Matrix

=end pod
